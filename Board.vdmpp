class Board
types
-- TODO Define types here
public BoardTiles = map seq of nat to Tile;
public Pieces = map seq of nat to Piece;
public Winner = <PLAYER1> | <PLAYER2> | <DRAW>
values
-- TODO Define values here
instance variables
-- TODO Define instance variables here
public tiles: BoardTiles := {|->};
public pieces: Pieces := {|->};
private playersWithPieces: set of Piece`Owner := {}
operations
-- TODO Define operations here
		public Board : () ==> Board
		Board() == (
			tiles := {
				[0, 0] |-> new PlainTile(),
				[0, 1] |-> new PlainTile(),
				[0, 2] |-> new TrapTile(<PLAYER1>),
				[0, 3] |-> new DenTile(<PLAYER1>),
				[0, 4] |-> new TrapTile(<PLAYER1>),
				[0, 5] |-> new PlainTile(),
				[0, 6] |-> new PlainTile(),
				
				[1, 0] |-> new PlainTile(),
				[1, 1] |-> new PlainTile(),
				[1, 2] |-> new PlainTile(),
				[1, 3] |-> new TrapTile(<PLAYER1>),
				[1, 4] |-> new PlainTile(),
				[1, 5] |-> new PlainTile(),
				[1, 6] |-> new PlainTile(),
				
				[2, 0] |-> new PlainTile(),
				[2, 1] |-> new PlainTile(),
				[2, 2] |-> new PlainTile(),
				[2, 3] |-> new PlainTile(),
				[2, 4] |-> new PlainTile(),
				[2, 5] |-> new PlainTile(),
				[2, 6] |-> new PlainTile(),
	
				[3, 0] |-> new PlainTile(),
				[3, 1] |-> new WaterTile(),
				[3, 2] |-> new WaterTile(),
				[3, 3] |-> new PlainTile(),
				[3, 4] |-> new WaterTile(),
				[3, 5] |-> new WaterTile(),
				[3, 6] |-> new PlainTile(),
				
				[4, 0] |-> new PlainTile(),
				[4, 1] |-> new WaterTile(),
				[4, 2] |-> new WaterTile(),
				[4, 3] |-> new PlainTile(),
				[4, 4] |-> new WaterTile(),
				[4, 5] |-> new WaterTile(),
				[4, 6] |-> new PlainTile(),
				
				[5, 0] |-> new PlainTile(),
				[5, 1] |-> new WaterTile(),
				[5, 2] |-> new WaterTile(),
				[5, 3] |-> new PlainTile(),
				[5, 4] |-> new WaterTile(),
				[5, 5] |-> new WaterTile(),
				[5, 6] |-> new PlainTile(),
	
				[6, 0] |-> new PlainTile(),
				[6, 1] |-> new PlainTile(),
				[6, 2] |-> new PlainTile(),
				[6, 3] |-> new PlainTile(),
				[6, 4] |-> new PlainTile(),
				[6, 5] |-> new PlainTile(),
				[6, 6] |-> new PlainTile(),
				
				[7, 0] |-> new PlainTile(),
				[7, 1] |-> new PlainTile(),
				[7, 2] |-> new PlainTile(),
				[7, 3] |-> new TrapTile(<PLAYER2>),
				[7, 4] |-> new PlainTile(),
				[7, 5] |-> new PlainTile(),
				[7, 6] |-> new PlainTile(),
				
				[8, 0] |-> new PlainTile(),
				[8, 1] |-> new PlainTile(),
				[8, 2] |-> new TrapTile(<PLAYER2>),
				[8, 3] |-> new DenTile(<PLAYER2>),
				[8, 4] |-> new TrapTile(<PLAYER2>),
				[8, 5] |-> new PlainTile(),
				[8, 6] |-> new PlainTile()
			};
			
			
			pieces := {
				[0, 0] |-> new TigerPiece(<PLAYER1>),
				[0, 6] |-> new LionPiece(<PLAYER1>),
				[1, 1] |-> new CatPiece(<PLAYER1>),
				[1, 5] |-> new DogPiece(<PLAYER1>),
				[2, 0] |-> new WolfPiece(<PLAYER1>),
				[2, 2] |-> new ElephantPiece(<PLAYER1>),
				[2, 4] |-> new LeopardPiece(<PLAYER1>),
				[2, 6] |-> new RatPiece(<PLAYER1>),
				
				[8, 6] |-> new TigerPiece(<PLAYER2>),
				[8, 0] |-> new LionPiece(<PLAYER2>),
				[7, 5] |-> new CatPiece(<PLAYER2>),
				[7, 1] |-> new DogPiece(<PLAYER2>),
				[6, 6] |-> new WolfPiece(<PLAYER2>),
				[6, 4] |-> new ElephantPiece(<PLAYER2>),
				[6, 2] |-> new LeopardPiece(<PLAYER2>),
				[6, 0] |-> new RatPiece(<PLAYER2>)		
			};
			return self
		);
		
		public Board : BoardTiles * Pieces ==> Board
		Board(bt, p) == (
				tiles := bt;
				pieces := p;
				return self
		)
		post tiles = bt and pieces = p and dom pieces subset dom tiles;
		
		-- MOVE
		
		public pure validBoard : () ==> bool
		validBoard() == (
				for all p in set dom pieces do
				(
					-- Se algum animal estiver num tile que nao pode estar, o board e invalido
					if tiles(p).type not in set pieces(p).steppableTiles then return false;
					-- Se um animal de algum jogador estiver no seu den, o board e invalido
					if tiles(p).type = "DenTile" and tiles(p).owner = pieces(p).owner then return false
				);
				return true
		);
		
		public pure validMove : seq of nat * seq of nat ==> bool
		validMove(source, dest) == (
				-- Se for um animal que esta na agua, se o destino for terra e estiver ocupado, o movimento nao e valido
				if tiles(source).type = WaterTile`TYPE and dest in set dom pieces and tiles(dest).type = "PlainTile" then return false;		
		
				-- Se for um animal que esta em terra, se o destino for agua e estiver ocupado, o movimento nao e valido
				if tiles(source).type = "PlainTile" and dest in set dom pieces and tiles(dest).type = "WaterTile" then return false;		
		
				-- Se se mover uma casa na horizontal ou na vertical, o movimento e valido
				if abs(dest(1)-source(1)) = 1 and source(2) = dest(2)
				then return true;
				
				if abs(dest(2)-source(2)) = 1 and source(1) = dest(1)
				then return true;
				
				-- Se for um leopardo/tigre, pode cruzar a totalidade de um rio na horizontal/vertical, desde que nao exista um rato no caminho
				if pieces(source).type = "LeopardPiece" or pieces(source).type = "TigerPiece" then (
						if source(2) = dest(2) then (
								if source(1) < dest(1) then (
										for all x in set {source(1), ..., dest(1)} do (
											if tiles([x, source(2)]).type <> "WaterTile" or pieces([x, source(2)]).type = "RatPiece" then return false
										);
										return true;
								)
								else (
										for all x in set {dest(1), ..., source(1)} do (
											if tiles([x, source(2)]).type <> "WaterTile" or pieces([x, source(2)]).type = "RatPiece" then return false
										);
										return true;
								)
						)
						elseif source(1) = dest(1) then (
								if source(2) < dest(2) then (
										for all y in set {source(2), ..., dest(2)} do (
											if tiles([source(1), y]).type <> "WaterTile" or pieces([source(1), y]).type = "RatPiece" then return false
										);
										return true;
								)
								else (
										for all y in set {dest(2), ..., source(2)} do (
											if tiles([source(1), y]).type <> "WaterTile" or pieces([source(1), y]).type = "RatPiece" then return false
										);
										return true
								)
						)
						else return false
				);
				return false	
		);
		
		private removePiece : seq of nat ==> ()
		removePiece(coord) == (
			pieces := {coord} <-: pieces
		)
		pre coord in set dom pieces;
		
		private addPiece : seq of nat * Piece ==> ()
		addPiece(coord, piece) == (
			pieces := pieces ++ {coord |-> piece}
		)
		pre coord not in set dom pieces and coord in set dom tiles;
		
		public movePiece : seq of nat * seq of nat ==> ()
		movePiece(coord1, coord2) == (
			addPiece(coord2, pieces(coord1));
			removePiece(coord1);
		)
		pre validMove(coord1, coord2)
		post validBoard();
		
		
		-- WINCON
		public checkWinCon : () ==> Winner
		checkWinCon() == (
				-- If one of the dens is occupied, the player that occupies it won the game
				for all coords in set dom pieces do (
						if tiles(coords).type = "DenTile" then
								return pieces(coords).owner
				);
				
				-- If a player has lost all pieces the other player won the game
				playersWithPieces := {};
				for all coords in set dom pieces do (
						if pieces(coords).owner not in set playersWithPieces then 
								playersWithPieces := playersWithPieces union {pieces(coords).owner}
				);
				if <PLAYER1> in set playersWithPieces and <PLAYER2> not in set playersWithPieces  then return <PLAYER1>
				elseif <PLAYER2> in set playersWithPieces and <PLAYER1> not in set playersWithPieces  then return <PLAYER2>
				elseif <PLAYER2> not in set playersWithPieces and <PLAYER1> not in set playersWithPieces  then return <DRAW>
				else return nil
		);
		
		-- CAPTURE
		public capture : seq of nat * Piece * Piece ==> set of seq1 of char
		capture(coord, attacker, defender) == (
				-- The rat can kill the elephant
				if attacker.type = "RatPiece" and defender.type = "ElephantPiece" then
						return {"attacker"};
				
				-- The player may capture any enemy piece in one of the player's trap squares regardless of rank.
				if tiles(coord).type = "TrapTile" then
						if defender.owner = tiles(coord).owner then return {"defender"}
						else return {"attacker"};
				
				-- Else, return the highest ranked piece. In case of a draw, both get captured
				if attacker.rank > defender.rank then return {"attacker"}
				elseif defender.rank > attacker.rank then return {"defender"}
				else return {"defender", "attacker"}
		)
		
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Board